<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>よけ</title>

<style>
  body { margin:0; font-family:sans-serif; overflow:hidden; }
  canvas {
    display:block;
    background:#000000;
    position:fixed;
    top:0;
    left:0;
    width:100vw;
    height:100vh;
  }

  /* UI（TIME / BEST / GLOBAL BEST） */
  #ui {
    position: absolute;
    top: 10px;
    left: 50%;
    transform: translateX(-50%);
    display: flex;
    flex-wrap: wrap;
    gap: 20px;
    font-size: 20px;
    text-shadow: 0 0 10px rgba(255,255,255,0.8);
    color: #ffffff;
    pointer-events:none;
    width: 90%;
    justify-content: center;
  }

  /* ゲーム開始ボタン */
  #startWrap {
    position:absolute;
    top:50%; left:50%;
    transform:translate(-50%,-50%);
    text-align:center;
  }
  #startBtn {
    font-size:28px;
    padding:15px 35px;
    background:#00aa55;
    color:white;
    border:none;
    border-radius:10px;
    box-shadow:0 0 15px #00aa55;
  }

  /* ゲームオーバー画面 */
  #gameover {
    position:absolute;
    top:50%; left:50%;
    transform:translate(-50%, -50%);
    font-size:32px;
    display:none;
    text-align:center;
    color:white;
    text-shadow:0 0 15px rgba(255,255,255,0.7);
  }

  button {
    margin-top:12px; padding:10px 22px; font-size:20px;
    cursor:pointer; border:none; border-radius:8px;
    background:#00aaff; color:white;
    box-shadow:0 0 12px #00aaff;
  }
  button:hover { background:#33bbff; }
</style>
</head>

<body>

<!-- UI -->
<div id="ui">
  <div id="score">TIME: 0.0</div>
  <div id="best">BEST: 0.0</div>
  <div id="global">GLOBAL BEST: 0.0</div>
</div>

<!-- ゲームスタート -->
<div id="startWrap">
  <button id="startBtn">ゲームスタート</button>
</div>

<!-- ゲームオーバーUI -->
<div id="gameover">
  <div id="result"></div>
  <button id="retry">もっかい</button>
  <button id="jumpBtn" style="
    margin-top:15px; padding:10px 22px; font-size:20px;
    background:#ff8800; border:none; color:white;
    border-radius:8px; box-shadow:0 0 12px #ff8800;
  ">ジャンプゲームへ</button>
</div>

<canvas id="game"></canvas>


<script>
/* ======================================================
    論理サイズ（ゲーム内部の固定サイズ）
====================================================== */
const LOGICAL_W = 400;
const LOGICAL_H = 600;

const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

/* ウィンドウサイズに応じて canvas をスケール */
function resizeCanvas() {
  const dpr = window.devicePixelRatio || 1;

  // CSSサイズ
  canvas.style.width = "100vw";
  canvas.style.height = "100vh";

  // 内部の実際のピクセル数（=論理サイズ × スケール）
  const rect = canvas.getBoundingClientRect();
  canvas.width = rect.width * dpr;
  canvas.height = rect.height * dpr;

  ctx.scale(dpr, dpr);
}
window.addEventListener("resize", resizeCanvas);
resizeCanvas();

/* 画面→論理座標変換 */
function screenToLogical(x, y) {
  const rect = canvas.getBoundingClientRect();
  const scaleX = LOGICAL_W / rect.width;
  const scaleY = LOGICAL_H / rect.height;

  return {
    x: x * scaleX,
    y: y * scaleY
  };
}

/* ------------------------------------------------------
    UI要素
------------------------------------------------------ */
const scoreText = document.getElementById("score");
const bestText = document.getElementById("best");
const globalText = document.getElementById("global");
const gameOverUI = document.getElementById("gameover");
const resultText = document.getElementById("result");
const retryBtn = document.getElementById("retry");
const startBtn = document.getElementById("startBtn");
const startWrap = document.getElementById("startWrap");

/* ローカル記録 */
let bestScore = parseFloat(localStorage.getItem("bestScore")) || 0;
let globalBest = parseFloat(localStorage.getItem("globalBest")) || 0;

bestText.textContent = "BEST: " + bestScore.toFixed(1);
globalText.textContent = "GLOBAL BEST: " + globalBest.toFixed(1);

/* ------------------------------------------------------
    ゲーム変数
------------------------------------------------------ */
let player, enemies, startTime, gameOver;
let enemyTimer = null;
let enemyInterval = 700;
let finalTime = 0;
let barrierCount = 0;
let milestoneTexts = [];
let lastMilestone = 0;
let running = false;

/* プレイヤー画像 */
const playerImg = new Image();
playerImg.src = "1000002537.png";

/* ======================================================
    初期化
====================================================== */
function init() {
  enemies = [];
  barrierCount = 0;
  gameOver = false;
  lastMilestone = 0;
  milestoneTexts = [];

  player = {
    x: LOGICAL_W / 2,
    y: LOGICAL_H - 50,
    size: 20,
    speed: 5
  };

  startTime = Date.now();
  finalTime = 0;
  enemyInterval = 700;

  if (enemyTimer) clearInterval(enemyTimer);
  enemyTimer = setInterval(spawnEnemy, enemyInterval);

  setInterval(() => {
    if (!gameOver) spawnBarrier();
  }, 10000 + Math.random() * 5000);
}

/* ------------------------------------------------------
    背景色 (HSV)
------------------------------------------------------ */
function hsvToRgb(h, s, v) {
  let f = (n) => {
    let k = (n + h / 60) % 6;
    return v - v * s * Math.max(Math.min(k, 4 - k, 1), 0);
  };
  return `rgb(${f(5) * 255 | 0}, ${f(3) * 255 | 0}, ${f(1) * 255 | 0})`;
}

function chooseEnemyColor(hue) {
  let enemyHue = (hue + 180 + (Math.random() * 60 - 30)) % 360;
  return `hsl(${enemyHue}, 90%, 60%)`;
}

/* 敵の出現頻度更新 */
function updateEnemySpawnRate() {
  let elapsed = (Date.now() - startTime) / 1000;
  let newInterval = Math.max(200, 700 - elapsed * 20);

  if (newInterval !== enemyInterval) {
    enemyInterval = newInterval;
    clearInterval(enemyTimer);
    enemyTimer = setInterval(spawnEnemy, enemyInterval);
  }
}

/* ------------------------------------------------------
    敵・バリア生成
------------------------------------------------------ */
function spawnEnemy() {
  if (gameOver) return;

  let elapsed = (Date.now() - startTime) / 1000;
  let difficulty = 1 + elapsed * 0.05;
  let bgHue = ((Date.now() - startTime) / 40) % 360;

  enemies.push({
    x: Math.random() * (LOGICAL_W - 20),
    y: -30,
    size: 20,
    speed: (2 + Math.random() * 3) * difficulty,
    color: chooseEnemyColor(bgHue),
    type: "enemy"
  });

  updateEnemySpawnRate();
}

function spawnBarrier() {
  enemies.push({
    x: Math.random() * (LOGICAL_W - 20),
    y: -30,
    size: 18,
    speed: 2,
    type: "barrier"
  });
}

/* ------------------------------------------------------
    入力
------------------------------------------------------ */
let keys = {};
document.addEventListener("keydown", e => keys[e.key] = true);
document.addEventListener("keyup", e => keys[e.key] = false);

/* スマホ移動（スケール対応） */
canvas.addEventListener("touchmove", e => {
  e.preventDefault();
  const pos = screenToLogical(
    e.touches[0].clientX - canvas.getBoundingClientRect().left,
    e.touches[0].clientY - canvas.getBoundingClientRect().top
  );
  player.x = pos.x;
  if (player.x < 20) player.x = 20;
  if (player.x > LOGICAL_W - 20) player.x = LOGICAL_W - 20;
});

/* ------------------------------------------------------
    描画
------------------------------------------------------ */
function drawPlayer() {
  if (!playerImg.complete) return;

  const w = 80;
  const h = 80;
  ctx.drawImage(playerImg, player.x - w / 2, player.y - h / 2, w, h);

  ctx.fillStyle = "pink";
  ctx.font = "22px sans-serif";
  ctx.fillText("❤️" + barrierCount, player.x + 35, player.y - 45);
}

function drawEnemy(e) {
  ctx.save();
  ctx.fillStyle = e.color;
  ctx.shadowColor = e.color;
  ctx.shadowBlur = 12;

  ctx.beginPath();
  ctx.moveTo(e.x, e.y + e.size);
  ctx.lineTo(e.x - e.size, e.y - e.size);
  ctx.lineTo(e.x + e.size, e.y - e.size);
  ctx.closePath();
  ctx.fill();

  ctx.restore();
}

function drawBarrier(b) {
  ctx.save();
  ctx.fillStyle = "pink";
  ctx.shadowColor = "pink";
  ctx.shadowBlur = 12;

  let x = b.x, y = b.y, s = b.size;
  ctx.beginPath();
  ctx.moveTo(x, y + s * 0.3);
  ctx.bezierCurveTo(x - s, y - s * 0.5, x - s, y + s * 0.8, x, y + s);
  ctx.bezierCurveTo(x + s, y + s * 0.8, x + s, y - s * 0.5, x, y + s * 0.3);
  ctx.fill();

  ctx.restore();
}

function hit(a, b) {
  const dx = a.x - b.x;
  const dy = a.y - b.y;
  return Math.sqrt(dx * dx + dy * dy) < a.size + b.size;
}

/* ======================================================
    メインループ
====================================================== */
function loop() {
  requestAnimationFrame(loop);

  if (!running) return;

  let hue = (Date.now() / 40) % 360;
  ctx.fillStyle = hsvToRgb(hue, 0.6, 0.25);
  ctx.fillRect(0, 0, LOGICAL_W, LOGICAL_H);

  let time = (Date.now() - startTime) / 1000;
  if (!gameOver) finalTime = time;
  scoreText.textContent = "TIME: " + finalTime.toFixed(1);

  /* 10秒ごとメッセージ */
  if (!gameOver && Math.floor(time / 10) > lastMilestone) {
    lastMilestone = Math.floor(time / 10);
    milestoneTexts.push({
      text: `${lastMilestone * 10} 秒経過！`,
      alpha: 1,
      y: 200
    });
  }

  if (!gameOver) {
    if (keys["ArrowLeft"] && player.x > 20) player.x -= player.speed;
    if (keys["ArrowRight"] && player.x < LOGICAL_W - 20) player.x += player.speed;

    drawPlayer();

    enemies.forEach(e => {
      e.y += e.speed;

      if (e.type === "barrier") drawBarrier(e);
      else drawEnemy(e);

      if (hit(player, e)) {
        if (e.type === "barrier") {
          barrierCount++;
          e.y = 9999;
        } else {
          if (barrierCount > 0) {
            barrierCount--;
            e.y = 9999;
          } else {
            endGame(time);
          }
        }
      }
    });
  }

  /* メッセージ演出 */
  milestoneTexts.forEach(m => {
    ctx.save();
    ctx.globalAlpha = m.alpha;
    ctx.fillStyle = "white";
    ctx.font = "40px sans-serif";
    ctx.textAlign = "center";
    ctx.fillText(m.text, LOGICAL_W / 2, m.y);
    ctx.restore();

    m.alpha -= 0.01;
    m.y -= 0.3;
  });

  milestoneTexts = milestoneTexts.filter(m => m.alpha > 0);
}

/* ======================================================
    ゲームオーバー
====================================================== */
function endGame(time) {
  gameOver = true;

  if (time > bestScore) {
    bestScore = time;
    localStorage.setItem("bestScore", bestScore);
    bestText.textContent = "BEST: " + bestScore.toFixed(1);
  }

  if (time > globalBest) {
    globalBest = time;
    localStorage.setItem("globalBest", globalBest);
    globalText.textContent = "GLOBAL BEST: " + globalBest.toFixed(1);
  }

  resultText.textContent = "ゲームオーバー！\n生存時間: " + time.toFixed(1) + " 秒";
  gameOverUI.style.display = "block";
}

/* ======================================================
    ボタンイベント
====================================================== */
retryBtn.addEventListener("click", () => {
  gameOverUI.style.display = "none";
  init();
});

document.getElementById("jumpBtn").addEventListener("click", () => {
  window.location.href = "jump.html";
});

startBtn.addEventListener("click", () => {
  startWrap.style.display = "none";
  running = true;
  init();
});

loop();
</script>

</body>
</html>
